---
title: "linear-regression"
author: "mht"
date: "June 26, 2016"
output: html_document
---
```{r}
library(rwebppl)
library(ggplot2)
library(tidyr)
library(dplyr)
library(coda)

setwd("~/Repos/psych201s/practicums")

estimate_mode <- function(s) {
  d <- density(s)
  return(d$x[which.max(d$y)])
}

HPDhi<- function(s){
  m <- HPDinterval(mcmc(s))
  return(m["var1","upper"])
}

HPDlo<- function(s){
  m <- HPDinterval(mcmc(s))
  return(m["var1","lower"])
}

runModelMCMC <- function(model, data_to_webppl, 
                         numSamples = 50000) {
  wp <- webppl(
    program_file = model,
    data = data_to_webppl,
    data_var = "observed_data", 
    inference_opts = list(method="MCMC", 
                          samples = numSamples, 
                          burn = numSamples/2,
                          verbose = TRUE),
    model_var = "model",
    output_format = "samples",
    packages = c("./utils")
    )
}

```

# Linear regression

```{r}
numSamples = 500000
observed_data <- data.frame(x = c(0,1,2,3), y = c(0,1,4,6));
res <- runModelMCMC("webppl_models/linearRegression.wppl", 
                    observed_data, numSamples = numSamples) 

res %>%
  gather(parameter, value) %>%
  mutate(parameter = factor(parameter, 
                            levels = c("intercept", "slope", "noise"))) %>%
  ggplot(aes(x = value))+
    geom_histogram()+
    facet_wrap(~parameter, scales = 'free')

res %>% 
  gather(parameter, value) %>%
  group_by(parameter) %>%
  summarize(mode = estimate_mode(value),
            md_lo = round(HPDlo(value), 3),
            md_hi = round(HPDhi(value), 3))
```

Visualize predictives

```{r}
ggplot(observed_data, aes(x = x,  y = y)) +
  geom_abline(data = sample_n(res, 400), 
              aes(intercept = intercept, slope = slope),
              alpha = .1) +
  geom_point(size = 10, color = "red") +
  geom_smooth(method = "lm", se = F, size = 2, color = "green") +
  ylab("y") +
  xlab("x") +
  xlim(-2, 8) +
  ylim(-2, 8) +
  theme_bw() 
```

# Logistic regression

In psychology, our dependent meaures are often *categorical* (e.g., did the participant behave prosocially vs. not? did the child interpret the evidence pragmatically vs. not? ...). For these problems, a special type of regression model is used: logistic regression (also called logit regression, which is somewhat funny because the logit function is the opposite of the logistic function).

You should be familiar with the [logistic function](https://en.wikipedia.org/wiki/Logistic_function), as it is very often used in modeling (no less in logistic regression). (It is also called a sigmoid function). It is an S-shaped curve, and it is a mapping from the real numbers (which can range from -Infinity to +Infinity) to numbers between 0 - 1 (aka probabilities). The opposite of the logistic function is a [logit function](https://en.wikipedia.org/wiki/Logit).

```{r}
numSamples = 50000

observed_data <- data.frame(x = c(0,1,2,3), y = c(T,T,F,F))

res <- runModelMCMC("webppl_models/logisticRegression.wppl", 
                    observed_data, numSamples = numSamples)

res %>%
  gather(parameter, value) %>%
  mutate(parameter = factor(parameter, 
                            levels = c("intercept", "slope", "noise"))) %>%
  ggplot(aes(x = value))+
    geom_histogram()+
    facet_wrap(~parameter, scales = 'free')

res %>% 
  gather(parameter, value) %>%
  group_by(parameter) %>%
  summarize(mode = estimate_mode(value),
            md_lo = round(HPDlo(value), 3),
            md_hi = round(HPDhi(value), 3))
```

Visualize predictives

```{r}
sample_n(res, 80) %>%
  ggplot() +
  geom_abline(aes(intercept = intercept, slope = slope), alpha = .5) +
  geom_point(aes(x = rep(observed_data$x, 20), 
                 y = rep(observed_data$y, 20)), 
                 size = 10, color = "red") +
  ylab("y") +
  xlab("x") +
  xlim(-2, 8) +
  ylim(-2, 8) +
  theme_bw() 
```

Compare to:

```{r}
summary(glm(y ~ x, data = observed_data, family = 'binomial'))
```

### Gibson & Wu (2012) -- Fixed effects

Now that we understand a what a simple linear regression looks like from a Bayesian viewpoint, we are ready to turn to the mixed-model example from Sorensen et al (2016). In this tutorial, we build up a progressively more complex Bayesian mixed-effects model on a real-world data set. 

The simplest model is a purely fixed effects model, where we assume that all data points are independent (i.e. have uncorrelated noise). The only additional change from the model above is that we assume reaction times are *log-normal*, meaning that the logarithm of the reaction times follows a normal distribution. We do this simply by taking the log of the input reaction times. 

(Note that for this data set, where each individual gives responses for many different items, a purely fixed-effects model will be a bad assumption. We will handle correlated errors in a mixed-model further below.)

```{r}
fixedEffectModel <- '
var linearFunction = function(x, b_0, b_1){
  return b_0 + b_1*x
}

var model = function() {
  var b_0 = sample(UniformDrift({a: -10, b: 10, r:.1}))
  var b_1 = sample(UniformDrift({a: -10, b: 10, r:.1}))
  var sigma = sample(UniformDrift({a: 0, b: 10, r:.1}))

  foreach(observed_data, function(dataPoint){
    var x = dataPoint["so"];
    var y = Math.log(dataPoint["rt"]);
    var predictedY = linearFunction(x, b_0, b_1)
    observe({
      data: y,
      link: Gaussian({mu: predictedY, sigma: sigma})
    })
  })

  return {b_0: b_0, b_1: b_1, sigma: sigma};
}
'

numSamples = 10000
GibsonWuData = read.table("../data/gibsonwu2012data.txt", header = T) %>%
  filter(region == "headnoun") %>%
  mutate(subj = as.integer(factor(subj)),
         item = as.integer(factor(item)),
         so = ifelse(type == "subj-ext", -1, 1)) %>%
  select(subj, item, so, rt)

res <- runModelMCMC(fixedEffectModel, GibsonWuData, numSamples = numSamples)

res %>%
  gather(parameter, value) %>%
  ggplot(aes(x = value))+
    geom_histogram()+
    facet_wrap(~parameter, scales = 'free')

res %>% 
  gather(parameter, value) %>%
  group_by(parameter) %>%
  summarize(mode = estimate_mode(value),
            md_lo = round(HPDlo(value), 3),
            md_hi = round(HPDhi(value), 3))
```

### Gibson & Wu (2012) -- Random intercepts

The problem with a pure fixed-effects model in this data set is that our observations are clustered in a natural way: we suspect that multiple observations from the same person or for the same item may be correlated. This violates the assumption of uncorrelated noise we made above. For example, some people may just be slower than other people, or some items may just be harder. To account for this variance, we add subject-level and item-level intercepts. 

Note that the Bayesian approach explicitly uses a generative model. Try writing the graphical model for this model. We start with sigmas giving the variability across the different intercepts, sample a set of intercepts with these sigmas, sample a set of fixed effects, and get a score for how likely the actual data would be with this set of choices. Over many samples, we can find distributions of values that make the data most likely, given our (relatively uninformative) priors.


```{r}
numSamples = 500

# if it runs with acc. ratio = 0.5 (or ratio = 1) for more than 100 iterations
# kill it and retry

res <- webppl(
    program_file = "webppl_models/varyingIntercepts.wppl",
    data = GibsonWuData,
    data_var = "observed_data",
    inference_opts = list(method="MCMC", 
                             kernel = list(HMC = 
                                      list(steps = 5,
                                           stepSize = 0.015)),
                          samples = numSamples, 
                          burn = numSamples/2,
                          verbose = TRUE),
    model_var = "model",
    output_format = "samples",
    packages = c("./utils")
  )

wp %>%
  gather(parameter, value) %>%
  ggplot(aes(x = value))+
    geom_histogram()+
    facet_wrap(~parameter, scales = 'free')

wp %>% 
  gather(parameter, value) %>%
  group_by(parameter) %>%
  summarize(mode = estimate_mode(value),
            md_lo = round(HPDlo(value), 3),
            md_hi = round(HPDhi(value), 3))
```

