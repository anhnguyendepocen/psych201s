---
title: 'Psych 201s: Distributions using WebPPL'
author: "mht"
date: "June 6, 2016"
output: html_document
---

A fundamental concept in probability and statistics is that of a probability distribution.
There are different "families" of distributions, corresponding to different "random processes". 

We'll consider a few here. 
We'll explore the distributions using WebPPL.

# Bernoulli distribution

The simplest probability distribution results from the random process of flipping a coin.
It is called a Bernoulli distribution (some people just call it a flip).

In WebPPL, you can access the flip of a single coin using the function `bernoulli`
```{r flip}
library(rwebppl)
webppl("bernoulli( { p : 0.5 } )")
```

Using RWebPPL, we will be writing the WebPPL model as a string `"flip({p:0.5})"`.
`flip` takes a single parameter `p` inside of a parameter object `{p:0.5}` (Note: This is the exactly the idea of a dictionary from Python, or a JSON object from JavaScript).

The function call is appreciably slower than `rbinom` because we are calling out to language WebPPL. 
This call is a fixed-cost, however, and will be worth it once we start considering more interesting cases than just a single coin flip.

Here, we've collected one sample. If we collect a bunch of samples, it would start to approximate the true distribution.

In WebPPL, distributions can be accessed directly. They are denoted by their proper names with capital letters. A full list of distributions can be found [here](http://webppl.readthedocs.io/en/master/distributions.html)

What happens if we make the same sort of call on the distribution `Bernoulli`?
```{r Bernoulli}
webppl("Bernoulli( { p: 0.5 } )")
```

We get out a table of probabilities. Each possible outcome of the random process (here, a coin flip) is an element of the **support**. Associated with each element of a support is the probability of that outcome. Note, unlike `bernoulli` (which can return different values each time you call it), `Bernoulli` is deterministic: It is a reflection of the true distribution. 

# Binomial distribution

What about if we wanted to flip the coin multiple times?
If we don't don't care about the order of the flips, then this is what's called the Binomial distribution.

```{r binomial.sample}
webppl("binomial( {n:3, p:0.5 } )")
```

`binomial` takes in parameters `n` and `p`, bundled together in the same object structure we saw above. `p` is the weight of the coin; same as in `bernoulli`. `n` is the number of times you flip it (or, the number of coins you flip).
Note that we know are getting out a number: it is the number of coins that came up heads (or, `TRUE`, as we saw above).

What does the distribution look like?

```{r binomial.dist}
webppl("Binomial( {n:3, p:0.5 } )")
```

Let's visualize this.

```{r binomial.dist.viz}
webppl("Binomial( {n:3, p:0.5 } )") %>%
  ggplot(., aes( x = support, y = prob ))+
  geom_bar( stat = 'identity', position = position_dodge() )
```

Interesting. So 1 and 2 heads are more probable than 0 or 3. Do you understand why?

Try changing `n`. What happens? Why? 

Try changing `p`. What happens? Why?

Try changing `n` to 6. And then play around with `p`. Imagine each support element is a position on a likert scale (add 1 to all the values if it makes you happy). What might `p` represent?

# Sampling

Often times, we don't have the true distribution to visualize. In these cases, we will have **samples** from the true distribution. We can use the function `repeat` to repeatedly sample. Check it out:

```{r sample.repeat}
webppl("
  var sampleLikert = function ( ) { return binomial( {n:6, p:0.8} + 1) }
  repeat(10, sampleLikert)
")
```

Now inside of our string `"..."`, we've actually written a whole program! This program has 2 lines. On the first line, we have made a new variable called `sampleLikert`. `sampleLikert` is a function (you can tell because it says `= function`). The empty parentheses `( )` is where the **arguments** of the function would normally go, but in this case, we've made a function that doesn't take any arguments. Inside of the curly-braces `{}` is what the function does. Here, what it does is sample from a `binomial` distribution and adds 1 to it. 

In the next line, we are repeating `sampleLikert` 10 times.

Notice that we can't call `repeat` on `binomial( {n:6, p:0.8} )`. The reason is that `binomial( {n:6, p:0.8} )` is not a function (it is a *call* to a function), and `repeat` wants to repeat **a function**. So what we did here was make a function called `sampleLikert`. (FYI: We could have called it anything we wanted to.)

Technically, we didn't have to make a new function and give it a name. We could have passed `function ( ) ... ` directly into repeat.

Just aesthetics.

Let's write it that way, and capture the output and visualize it.
```{r sample.repeat.2}
x <- webppl("
  repeat(100, function ( ) { return binomial( {n:6, p:0.8} ) + 1 } )
")
print(x)
qplot(x)
```





